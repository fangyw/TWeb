#ifndef __LABEL_H__
#define __LABEL_H__
#include "Maps.h"
#include "Sentence.h"
#include <unordered_map>
using std::unordered_map;
class CStringIDMap
{
public:
	static const int s_UnkID = -1;
	void Add(const wstring &POS)
	{
		if (s_POS2IDMap.find(POS) == s_POS2IDMap.end())
		{
			s_POS2IDMap[POS] = s_POSVec.size();
			s_POSVec.push_back(POS);
		}
	}

	int GetID(const wstring &POS)
	{
		unordered_map<wstring, int>::iterator iter = s_POS2IDMap.find(POS);
		return iter == s_POS2IDMap.end() ? s_POSUnkID:iter->second;
	}

	void Save(const string & strPath)
	{
		FILE *fp = fopen(strPath.c_str(), "w");
		assert(fp);
		for (size_t i = 0; i < s_POSVec.size(); ++i)
			fwprintf(fp, L"%ls\n", s_POSVec[i].c_str());
		fclose(fp);
	}

	void Load(const string & strPath)
	{
		FILE *fp = fopen(strPath.c_str(), "r");
		assert(fp);
		const int MAX_POS_LEN = 64;
		wchar_t buf[MAX_POS_LEN];
		while (fgetws(buf, MAX_POS_LEN, fp) != NULL)
		{
			removeNewLine(buf);
			if (s_POS2IDMap.find(buf) != s_POS2IDMap.end())
			{
				fprintf(stderr, "Error: duplicate pos tag\n");
				exit(0);
			}
			AddPOSTag(buf);	
		}
		fprintf(stderr, "Total %d POS Tags\n", (int)s_POSVec.size());
		fclose(fp);
	}
	
	int Size()											{return m_StrVec.size();}
	vector<wstring> & GetStrVec()		{return m_StrVec;}
	wstring & GetStr(int ID)				{return m_StrVec[ID];}

private:
	unordered_map<wstring, int> 		m_Str2IDMap;
	vector<wstring> 								m_StrVec;
};


};

class CPOSIDMap
{
public:
	static const int s_POSUnkID = -1;
	static void AddPOSTag(const wstring &POS)
	{
		if (s_POS2IDMap.find(POS) == s_POS2IDMap.end())
		{
			s_POS2IDMap[POS] = s_POSVec.size();
			s_POSVec.push_back(POS);
		}
	}

	static int GetPOSID(const wstring &POS)
	{
		unordered_map<wstring, int>::iterator iter = s_POS2IDMap.find(POS);
		return iter == s_POS2IDMap.end() ? s_POSUnkID:iter->second;
	}

  static void CollectPOS(vector<_SEN *> & senVec)
  {
    for (size_t i = 0; i < senVec.size(); ++i)
    {
      _SEN *pSen = senVec[i];
      for (int idx = 0; idx < pSen->Length(); ++ idx)
        AddPOSTag(pSen->Tag(idx));
    }
  }

	static void Save(const string & strPath)
	{
		FILE *fp = fopen(strPath.c_str(), "w");
		assert(fp);
		for (size_t i = 0; i < s_POSVec.size(); ++i)
			fwprintf(fp, L"%ls\n", s_POSVec[i].c_str());
		fclose(fp);
	}

	static void Load(const string & strPath)
	{
		FILE *fp = fopen(strPath.c_str(), "r");
		assert(fp);
		const int MAX_POS_LEN = 64;
		wchar_t buf[MAX_POS_LEN];
		while (fgetws(buf, MAX_POS_LEN, fp) != NULL)
		{
			removeNewLine(buf);
			if (s_POS2IDMap.find(buf) != s_POS2IDMap.end())
			{
				fprintf(stderr, "Error: duplicate pos tag\n");
				exit(0);
			}
			AddPOSTag(buf);	
		}
		fprintf(stderr, "Total %d POS Tags\n", (int)s_POSVec.size());
		fclose(fp);
	}
	
	static int GetPOSNum()									{return s_POSVec.size();}
	static vector<wstring> & GetPOSVec()		{return s_POSVec;}
	static wstring & GetPOS(int id)					{return s_POSVec[id];}
private:
	static unordered_map<wstring, int> 		s_POS2IDMap;
	static vector<wstring> 								s_POSVec;
};

#endif  /*__LABEL_H__*/
